Description,Target,Expression
,is_joint,(df.number_of_participants > 1)
local,_DF_IS_DEPART,'depart' in df.columns
#local,_DF_IS_DEPART,'depart' in df.columns
,is_indiv,(df.number_of_participants == 1)
,is_atwork_subtour,~df.parent_tour_id.isnull()
,c_cost,(0.60 * c_ivt) / df.value_of_time
#,,
#atwork subtours,,
#FIXME tripModeChoice uec wrongly conflates these with tour_mode_is_bike?,,
,parent_tour_mode,"reindex(tours.tour_mode, df.parent_tour_id).fillna('')"
,work_tour_is_SOV,"parent_tour_mode.isin(['DRIVEALONEFREE','DRIVEALONEPAY'])"
,work_tour_is_bike,parent_tour_mode=='BIKE'
#,,
,i_tour_mode,df.tour_mode.map(I_MODE_MAP)
,tour_mode_is_SOV,i_tour_mode.isin(I_SOV_MODES)
,tour_mode_is_auto,i_tour_mode.isin(I_AUTO_MODES)
,tour_mode_is_walk,i_tour_mode == I_WALK_MODE
,tour_mode_is_bike,i_tour_mode == I_BIKE_MODE
,tour_mode_is_walk_transit,i_tour_mode.isin(I_WALK_TRANSIT_MODES)
,tour_mode_is_drive_transit,i_tour_mode.isin(I_DRIVE_TRANSIT_MODES)
,tour_mode_is_ride_hail,i_tour_mode.isin(I_RIDE_HAIL_MODES)
#,,
,inbound,~df.outbound
,first_trip,df.trip_num == 1
,last_trip,df.trip_num == df.trip_count
origin terminal time not counted at home,_origin_terminal_time,"np.where(df.outbound & first_trip, 0, reindex(land_use.TERMINAL, df[ORIGIN]))"
dest terminal time not counted at home,_dest_terminal_time,"np.where(inbound & last_trip, 0, reindex(land_use.TERMINAL, df[DESTINATION]))"
,total_terminal_time,_origin_terminal_time + _dest_terminal_time
#,,
,free_parking_available,(df.tour_type == 'work') & df.free_parking_at_work
,dest_hourly_peak_parking_cost,"reindex(land_use.PRKCST, df[DESTINATION])"
,origin_hourly_peak_parking_cost,"reindex(land_use.PRKCST, df[ORIGIN])"
,origin_duration,"np.where(first_trip, np.where(inbound,df.duration * ~free_parking_available,0), 1)"
,dest_duration,"np.where(last_trip, np.where(inbound, df.duration * ~free_parking_available, 0), 1)"
,origin_parking_cost,origin_duration*origin_hourly_peak_parking_cost
,dest_parking_cost,dest_duration*dest_hourly_peak_parking_cost
,total_parking_cost,(origin_parking_cost + dest_parking_cost) / 2.0
,trip_topology,"np.where(df.outbound, reindex(land_use.TOPOLOGY, df[DESTINATION]), reindex(land_use.TOPOLOGY, df[ORIGIN]))"
,density_index,"np.where(df.outbound, reindex(land_use.density_index, df[DESTINATION]), reindex(land_use.density_index, df[ORIGIN]))"
,origin_density_index,"np.where(df.outbound, reindex(land_use.density_index, df[ORIGIN]), reindex(land_use.density_index, df[DESTINATION]))"
# FIXME no transit subzones so all zones short walk to transit,,
,_walk_transit_origin,True
,_walk_transit_destination,True
,walk_transit_available,_walk_transit_origin & _walk_transit_destination
,drive_transit_available,"np.where(df.outbound, _walk_transit_destination, _walk_transit_origin) & (df.auto_ownership > 0)"
,origin_walk_time,shortWalk*60/walkSpeed
,destination_walk_time,shortWalk*60/walkSpeed
# RIDEHAIL,, Could just define this in trip_mode_choice.csv but leaving this for now so that we can factor in rejected trips if needed
,origTaxiWaitTime,"odt_skims['RH_SOLO_WAIT'] * (1.0 - odt_skims['RH_SOLO_REJECTIONPROB']) + TNC_missed_trip_penalty * odt_skims['RH_SOLO_REJECTIONPROB']"
,origSingleTNCWaitTime,"odt_skims['RH_SOLO_WAIT'] * (1.0 - odt_skims['RH_SOLO_REJECTIONPROB']) + TNC_missed_trip_penalty * odt_skims['RH_SOLO_REJECTIONPROB']"
,origSharedTNCWaitTime,"odt_skims['RH_POOLED_WAIT'] * (1.0 - odt_skims['RH_POOLED_REJECTIONPROB']) + TNC_missed_trip_penalty * odt_skims['RH_POOLED_REJECTIONPROB']"
#,,
,sov_available,odt_skims['SOV_TIME']>0
,hov2_available,odt_skims['HOV2_TIME']>0
,hov3_available,odt_skims['HOV3_TIME']>0
,sovtoll_available,odt_skims['SOVTOLL_VTOLL']>0
,hov2toll_available,odt_skims['HOV2TOLL_VTOLL']>0
,hov3toll_available,odt_skims['HOV3TOLL_VTOLL']>0
,walk_local_available,walk_transit_available & (odt_skims['WLK_LOC_WLK_TOTIVT']/100>0)
,walk_lrf_available,walk_transit_available & (i_tour_mode >= 10) & (odt_skims['WLK_LRF_WLK_KEYIVT']/100>0)
,walk_express_available,walk_transit_available & (i_tour_mode >= 11) & (odt_skims['WLK_EXP_WLK_KEYIVT']/100>0)
,walk_heavyrail_available,walk_transit_available & (i_tour_mode >= 12) & (odt_skims['WLK_HVY_WLK_KEYIVT']/100>0)
,walk_commuter_available,walk_transit_available & (i_tour_mode >= 13) & (odt_skims['WLK_COM_WLK_KEYIVT']/100>0)
,drive_local_available_outbound,drive_transit_available & df.outbound & (odt_skims['DRV_LOC_WLK_TOTIVT']/100>0)
,drive_local_available_inbound,drive_transit_available & ~df.outbound & (odt_skims['WLK_LOC_DRV_TOTIVT']/100>0)
,drive_lrf_available_outbound,drive_transit_available & df.outbound & (i_tour_mode >= 15) & (odt_skims['DRV_LRF_WLK_KEYIVT']/100>0)
,drive_lrf_available_inbound,drive_transit_available & ~df.outbound & (i_tour_mode >= 15) & (odt_skims['WLK_LRF_DRV_KEYIVT']/100>0)
,drive_express_available_outbound,drive_transit_available & df.outbound & (i_tour_mode >= 16) & (odt_skims['DRV_EXP_WLK_KEYIVT']/100>0)
,drive_express_available_inbound,drive_transit_available & ~df.outbound & (i_tour_mode >= 16) & (odt_skims['WLK_EXP_DRV_KEYIVT']/100>0)
,drive_heavyrail_available_outbound,drive_transit_available & df.outbound & (i_tour_mode >= 17) & (odt_skims['DRV_HVY_WLK_KEYIVT']/100>0)
,drive_heavyrail_available_inbound,drive_transit_available & ~df.outbound & (i_tour_mode >= 17) & (odt_skims['WLK_HVY_DRV_KEYIVT']/100>0)
,drive_commuter_available_outbound,drive_transit_available & df.outbound & (i_tour_mode >= 18) & (odt_skims['DRV_COM_WLK_KEYIVT']/100>0)
,drive_commuter_available_inbound,drive_transit_available & ~df.outbound & (i_tour_mode >= 18) & (odt_skims['WLK_COM_DRV_KEYIVT']/100>0)
,walk_ferry_available,walk_lrf_available & (odt_skims['WLK_LRF_WLK_FERRYIVT']/100>0)
,_drive_ferry_available_outbound,drive_lrf_available_outbound & (odt_skims['DRV_LRF_WLK_FERRYIVT']/100>0)
,_drive_ferry_available_inbound,drive_lrf_available_inbound & (odt_skims['WLK_LRF_DRV_FERRYIVT']/100>0)
,drive_ferry_available,"np.where(df.outbound, _drive_ferry_available_outbound, _drive_ferry_available_inbound)"
#,od_dist_walk,od_skims['DISTWALK']
#,do_dist_walk,od_skims.reverse('DISTWALK')
#,max_dist_walk,od_skims.max('DISTWALK')
#,dist_bike,od_skims['DISTBIKE']
#,dist_only,od_skims['DIST']
,is_dest_cordon, ((df[DESTINATION].isin(LIST_SMALL_CORDON_TAZS_SF)) & (~df[ORIGIN].isin(LIST_SMALL_CORDON_TAZS_SF)))
,is_dest_orig_cordon,((df[ORIGIN].isin(LIST_SMALL_CORDON_TAZS_SF)) | (df[DESTINATION].isin(LIST_SMALL_CORDON_TAZS_SF)))
,is_income_very_low, (((df.income_in_thousands>0)  & (df.income_in_thousands<=46)  & (df.hhsize == 1)) | ((df.income_in_thousands>46)  & (df.income_in_thousands<=53)  & (df.hhsize == 2)) | ((df.income_in_thousands>53)  & (df.income_in_thousands<=59)  & (df.hhsize == 3)) | ((df.income_in_thousands>59)  & (df.income_in_thousands<=65)  & (df.hhsize == 4)))
,is_income_low,      (((df.income_in_thousands>0)  & (df.income_in_thousands<=66)  & (df.hhsize == 1)) | ((df.income_in_thousands>66)  & (df.income_in_thousands<=76)  & (df.hhsize == 2)) | ((df.income_in_thousands>76)  & (df.income_in_thousands<=85)  & (df.hhsize == 3)) | ((df.income_in_thousands>85)  & (df.income_in_thousands<=95)  & (df.hhsize == 4)))
,is_income_moderate, (((df.income_in_thousands>0)  & (df.income_in_thousands<=100) & (df.hhsize == 1)) | ((df.income_in_thousands>100) & (df.income_in_thousands<=114) & (df.hhsize == 2)) | ((df.income_in_thousands>114) & (df.income_in_thousands<=128) & (df.hhsize == 3)) | ((df.income_in_thousands>128) & (df.income_in_thousands<=142) & (df.hhsize == 4)))
,is_income_medium,   (((df.income_in_thousands>0)  & (df.income_in_thousands<=116) & (df.hhsize == 1)) | ((df.income_in_thousands>116) & (df.income_in_thousands<=133) & (df.hhsize == 2)) | ((df.income_in_thousands>133) & (df.income_in_thousands<=149) & (df.hhsize == 3)) | ((df.income_in_thousands>149) & (df.income_in_thousands<=166) & (df.hhsize == 4)))
,is_income_high,     (((df.income_in_thousands>116)                                & (df.hhsize == 1)) | ((df.income_in_thousands>133)                                 & (df.hhsize == 2)) | ((df.income_in_thousands>149)                                 & (df.hhsize == 3)) | ((df.income_in_thousands>166)                                 & (df.hhsize == 4)))
,is_peak, (((df.depart>=6) & (df.depart<9)) | ((df.depart>=15) & (df.depart<=18) ))  if _DF_IS_DEPART else 1


